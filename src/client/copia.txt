import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import Stats from 'three/examples/jsm/libs/stats.module';
import { GUI } from 'dat.gui';

import { SunModule } from './SunModule';
import { EarthModule } from './EarthModule';
import { MoonModule } from './MoonModule';

const scene = new THREE.Scene();
const sun = new SunModule();
const earth = new EarthModule();
const moon = new MoonModule();

sun.addToScene(scene);
earth.addToScene(scene);
moon.addToScene(scene);

scene.add(new THREE.AxesHelper(5));

const light = new THREE.PointLight(0xffffff, 50);
light.position.set(0.8, 1.4, 1.0);
scene.add(light);

const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.set(0.8, 1.4, 1.0);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

new OrbitControls(camera, renderer.domElement);

// Material para el Coliseo
const colosseumMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaff });

const fbxLoader_Character = new FBXLoader();
fbxLoader_Character.load(
    'models/KachujinGRosales.fbx',
    (object) => {
        object.scale.set(.001, .001, .001);
        scene.add(object);
    },
    (xhr) => {
        console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
    },
    (error) => {
        console.log(error);
    }
);

const fbxLoader = new FBXLoader();
fbxLoader.load('models/colosseum.fbx', (object) => {
    object.traverse((child) => {
        if ((child as THREE.Mesh).isMesh) {
            (child as THREE.Mesh).material = colosseumMaterial;
        }
    });
    object.scale.set(.01, .01, .01);
    scene.add(object);
});

window.addEventListener('resize', onWindowResize, false);
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

const stats = new Stats();
document.body.appendChild(stats.dom);

const gui = new GUI();

// Datos para la GUI
const data = {
    color: light.color.getHex(),
    ambientColor: ambientLight.color.getHex(),
    lightIntensity: light.intensity,
    ambientIntensity: ambientLight.intensity,
    colosseumColor: colosseumMaterial.color.getHex() // Color inicial del Coliseo
};

const lightFolder = gui.addFolder('Point Light');
lightFolder.addColor(data, 'color').onChange(() => {
    light.color.setHex(Number(data.color.toString().replace('#', '0x')));
});
lightFolder.add(data, 'lightIntensity', 0, 100, 1).onChange(() => {
    light.intensity = data.lightIntensity;
});

const ambientLightFolder = gui.addFolder('Ambient Light');
ambientLightFolder.addColor(data, 'ambientColor').onChange(() => {
    ambientLight.color.setHex(Number(data.ambientColor.toString().replace('#', '0x')));
});
ambientLightFolder.add(data, 'ambientIntensity', 0, 100, 1).onChange(() => {
    ambientLight.intensity = data.ambientIntensity;
});

// Añadir control de color para el Coliseo en dat.GUI
gui.addColor(data, 'colosseumColor').onChange((hexColor) => {
    colosseumMaterial.color.setHex(hexColor);
});

// Crear la esfera (sol)
const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);

// Material con emisión de luz
const sphereMaterial = new THREE.MeshStandardMaterial({
    color: 0xffaa00,  // Color de la esfera
    emissive: 0xffaa00,  // Color de la emisión
    emissiveIntensity: 1
});

const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

// Posición inicial de la esfera
sphere.position.set(1, 3, 0);
scene.add(sphere);

// Luz puntual que coincide con la esfera
const pointLight = new THREE.PointLight(0xffaa00, 50, 5);
pointLight.position.set(sphere.position.x, sphere.position.y, sphere.position.z);
scene.add(pointLight);

// Variables para el movimiento orbital
let angle = 0;
const radius = 1; // Radio de la órbita
const speed = 0.01; // Velocidad de la órbita

function animate() {
    requestAnimationFrame(animate);

    // Actualizar la posición de la esfera y la luz para la órbita
    angle += speed;
    sphere.position.x = Math.cos(angle) * radius;
    sphere.position.z = Math.sin(angle) * radius;

    // Mover la luz con la esfera
    pointLight.position.set(sphere.position.x, sphere.position.y, sphere.position.z);

    render();
    stats.update();
}
function render() {
    renderer.render(scene, camera);
}

animate();
